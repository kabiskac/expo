{"version":3,"file":"Location.js","sourceRoot":"","sources":["../src/Location.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  PermissionStatus,\r\n  PermissionResponse,\r\n  PermissionHookOptions,\r\n  createPermissionHook,\r\n  Platform,\r\n} from 'expo-modules-core';\r\n\r\nimport ExpoLocation from './ExpoLocation';\r\nimport {\r\n  LocationAccuracy,\r\n  LocationCallback,\r\n  LocationGeocodedAddress,\r\n  LocationGeocodedLocation,\r\n  LocationHeadingCallback,\r\n  LocationHeadingObject,\r\n  LocationLastKnownOptions,\r\n  LocationObject,\r\n  LocationOptions,\r\n  LocationPermissionResponse,\r\n  LocationProviderStatus,\r\n  LocationRegion,\r\n  LocationSubscription,\r\n  LocationTaskOptions,\r\n  LocationActivityType,\r\n  LocationGeofencingEventType,\r\n  LocationGeofencingRegionState,\r\n  LocationGeocodingOptions,\r\n} from './Location.types';\r\nimport { LocationEventEmitter } from './LocationEventEmitter';\r\nimport {\r\n  setGoogleApiKey,\r\n  googleGeocodeAsync,\r\n  googleReverseGeocodeAsync,\r\n} from './LocationGoogleGeocoding';\r\nimport { LocationSubscriber, HeadingSubscriber, _getCurrentWatchId } from './LocationSubscribers';\r\n\r\n// @needsAudit\r\n/**\r\n * Check status of location providers.\r\n * @return A promise which fulfills with an object of type [LocationProviderStatus](#locationproviderstatus).\r\n */\r\nexport async function getProviderStatusAsync(): Promise<LocationProviderStatus> {\r\n  return ExpoLocation.getProviderStatusAsync();\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Asks the user to turn on high accuracy location mode which enables network provider that uses\r\n * Google Play services to improve location accuracy and location-based services.\r\n * @return A promise resolving as soon as the user accepts the dialog. Rejects if denied.\r\n */\r\nexport async function enableNetworkProviderAsync(): Promise<void> {\r\n  // If network provider is disabled (user's location mode is set to \"Device only\"),\r\n  // Android's location provider may not give you any results. Use this method in order to ask the user\r\n  // to change the location mode to \"High accuracy\" which uses Google Play services and enables network provider.\r\n  // `getCurrentPositionAsync` and `watchPositionAsync` are doing it automatically anyway.\r\n\r\n  if (Platform.OS === 'android') {\r\n    return ExpoLocation.enableNetworkProviderAsync();\r\n  }\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Requests for one-time delivery of the user's current location.\r\n * Depending on given `accuracy` option it may take some time to resolve,\r\n * especially when you're inside a building.\r\n * > __Note:__ Calling it causes the location manager to obtain a location fix which may take several\r\n * > seconds. Consider using [`Location.getLastKnownPositionAsync`](#locationgetlastknownpositionasyncoptions)\r\n * > if you expect to get a quick response and high accuracy is not required.\r\n * @param options\r\n * @return A promise which fulfills with an object of type [`LocationObject`](#locationobject).\r\n */\r\nexport async function getCurrentPositionAsync(\r\n  options: LocationOptions = {}\r\n): Promise<LocationObject> {\r\n  return ExpoLocation.getCurrentPositionAsync(options);\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Gets the last known position of the device or `null` if it's not available or doesn't match given\r\n * requirements such as maximum age or required accuracy.\r\n * It's considered to be faster than `getCurrentPositionAsync` as it doesn't request for the current\r\n * location, but keep in mind the returned location may not be up-to-date.\r\n * @param options\r\n * @return A promise which fulfills with an object of type [LocationObject](#locationobject) or\r\n * `null` if it's not available or doesn't match given requirements such as maximum age or required\r\n * accuracy.\r\n */\r\nexport async function getLastKnownPositionAsync(\r\n  options: LocationLastKnownOptions = {}\r\n): Promise<LocationObject | null> {\r\n  return ExpoLocation.getLastKnownPositionAsync(options);\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Subscribe to location updates from the device. Please note that updates will only occur while the\r\n * application is in the foreground. To get location updates while in background you'll need to use\r\n * [Location.startLocationUpdatesAsync](#locationstartlocationupdatesasynctaskname-options).\r\n * @param options\r\n * @param callback This function is called on each location update. It receives an object of type\r\n * [`LocationObject`](#locationobject) as the first argument.\r\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\r\n */\r\nexport async function watchPositionAsync(\r\n  options: LocationOptions,\r\n  callback: LocationCallback\r\n): Promise<LocationSubscription> {\r\n  const watchId = LocationSubscriber.registerCallback(callback);\r\n  await ExpoLocation.watchPositionImplAsync(watchId, options);\r\n\r\n  return {\r\n    remove() {\r\n      LocationSubscriber.unregisterCallback(watchId);\r\n    },\r\n  };\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Gets the current heading information from the device. To simplify, it calls `watchHeadingAsync`\r\n * and waits for a couple of updates, and then returns the one that is accurate enough.\r\n * @return A promise which fulfills with an object of type [LocationHeadingObject](#locationheadingobject).\r\n */\r\nexport async function getHeadingAsync(): Promise<LocationHeadingObject> {\r\n  return new Promise(async (resolve) => {\r\n    let tries = 0;\r\n\r\n    const subscription = await watchHeadingAsync((heading) => {\r\n      if (heading.accuracy > 1 || tries > 5) {\r\n        subscription.remove();\r\n        resolve(heading);\r\n      } else {\r\n        tries += 1;\r\n      }\r\n    });\r\n  });\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Subscribe to compass updates from the device.\r\n * @param callback This function is called on each compass update. It receives an object of type\r\n * [LocationHeadingObject](#locationheadingobject) as the first argument.\r\n * @return A promise which fulfills with a [`LocationSubscription`](#locationsubscription) object.\r\n */\r\nexport async function watchHeadingAsync(\r\n  callback: LocationHeadingCallback\r\n): Promise<LocationSubscription> {\r\n  const watchId = HeadingSubscriber.registerCallback(callback);\r\n  await ExpoLocation.watchDeviceHeading(watchId);\r\n\r\n  return {\r\n    remove() {\r\n      HeadingSubscriber.unregisterCallback(watchId);\r\n    },\r\n  };\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Geocode an address string to latitude-longitude location.\r\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\r\n * > requests at a time can result in an error, so they have to be managed properly.\r\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\r\n * > be shown to the user immediately.\r\n *\r\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\r\n * > before geocoding can be used.\r\n * @param address A string representing address, eg. `\"Baker Street London\"`.\r\n * @param options\r\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedLocation`](#locationgeocodedlocation) objects.\r\n */\r\nexport async function geocodeAsync(\r\n  address: string,\r\n  options?: LocationGeocodingOptions\r\n): Promise<LocationGeocodedLocation[]> {\r\n  if (typeof address !== 'string') {\r\n    throw new TypeError(`Address to geocode must be a string. Got ${address} instead.`);\r\n  }\r\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\r\n    return await googleGeocodeAsync(address);\r\n  }\r\n  return await ExpoLocation.geocodeAsync(address);\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Reverse geocode a location to postal address.\r\n * > **Note**: Geocoding is resource consuming and has to be used reasonably. Creating too many\r\n * > requests at a time can result in an error, so they have to be managed properly.\r\n * > It's also discouraged to use geocoding while the app is in the background and its results won't\r\n * > be shown to the user immediately.\r\n *\r\n * > On Android, you must request a location permission (`Permissions.LOCATION`) from the user\r\n * > before geocoding can be used.\r\n * @param location An object representing a location.\r\n * @param options\r\n * @return A promise which fulfills with an array (in most cases its size is 1) of [`LocationGeocodedAddress`](#locationgeocodedaddress) objects.\r\n */\r\nexport async function reverseGeocodeAsync(\r\n  location: Pick<LocationGeocodedLocation, 'latitude' | 'longitude'>,\r\n  options?: LocationGeocodingOptions\r\n): Promise<LocationGeocodedAddress[]> {\r\n  if (typeof location.latitude !== 'number' || typeof location.longitude !== 'number') {\r\n    throw new TypeError(\r\n      'Location to reverse-geocode must be an object with number properties `latitude` and `longitude`.'\r\n    );\r\n  }\r\n  if (options?.useGoogleMaps || Platform.OS === 'web') {\r\n    return await googleReverseGeocodeAsync(location);\r\n  }\r\n  return await ExpoLocation.reverseGeocodeAsync(location);\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Checks user's permissions for accessing location.\r\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\r\n * @deprecated __Deprecated.__ Use [`getForegroundPermissionsAsync`](#locationgetforegroundpermissionsasync) or [`getBackgroundPermissionsAsync`](#locationgetbackgroundpermissionsasync) instead.\r\n */\r\nexport async function getPermissionsAsync(): Promise<LocationPermissionResponse> {\r\n  console.warn(\r\n    `\"getPermissionsAsync()\" is now deprecated. Please use \"getForegroundPermissionsAsync()\" or \"getBackgroundPermissionsAsync()\" instead.`\r\n  );\r\n  return await ExpoLocation.getPermissionsAsync();\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Asks the user to grant permissions for location.\r\n * @return A promise that fulfills with an object of type [LocationPermissionResponse](#locationpermissionresponse).\r\n * @deprecated __Deprecated.__ Use [`requestForegroundPermissionsAsync`](#locationrequestforegroundpermissionsasync) or [`requestBackgroundPermissionsAsync`](#locationrequestbackgroundpermissionsasync) instead.\r\n */\r\nexport async function requestPermissionsAsync(): Promise<LocationPermissionResponse> {\r\n  console.warn(\r\n    `\"requestPermissionsAsync()\" is now deprecated. Please use \"requestForegroundPermissionsAsync()\" or \"requestBackgroundPermissionsAsync()\" instead.`\r\n  );\r\n\r\n  return await ExpoLocation.requestPermissionsAsync();\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Checks user's permissions for accessing location while the app is in the foreground.\r\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\r\n */\r\nexport async function getForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\r\n  return await ExpoLocation.getForegroundPermissionsAsync();\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Asks the user to grant permissions for location while the app is in the foreground.\r\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\r\n */\r\nexport async function requestForegroundPermissionsAsync(): Promise<LocationPermissionResponse> {\r\n  return await ExpoLocation.requestForegroundPermissionsAsync();\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Check or request permissions for the foreground location.\r\n * This uses both `requestForegroundPermissionsAsync` and `getForegroundPermissionsAsync` to interact with the permissions.\r\n *\r\n * @example\r\n * ```ts\r\n * const [status, requestPermission] = Location.useForegroundPermissions();\r\n * ```\r\n */\r\nexport const useForegroundPermissions = createPermissionHook({\r\n  getMethod: getForegroundPermissionsAsync,\r\n  requestMethod: requestForegroundPermissionsAsync,\r\n});\r\n\r\n// @needsAudit\r\n/**\r\n * Checks user's permissions for accessing location while the app is in the background.\r\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\r\n */\r\nexport async function getBackgroundPermissionsAsync(): Promise<PermissionResponse> {\r\n  return await ExpoLocation.getBackgroundPermissionsAsync();\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Asks the user to grant permissions for location while the app is in the background.\r\n * On __Android 11 or higher__: this method will open the system settings page - before that happens\r\n * you should explain to the user why your application needs background location permission.\r\n * For example, you can use `Modal` component from `react-native` to do that.\r\n * > __Note__: Foreground permissions should be granted before asking for the background permissions\r\n * (your app can't obtain background permission without foreground permission).\r\n * @return A promise that fulfills with an object of type [PermissionResponse](#permissionresponse).\r\n */\r\nexport async function requestBackgroundPermissionsAsync(): Promise<PermissionResponse> {\r\n  return await ExpoLocation.requestBackgroundPermissionsAsync();\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Check or request permissions for the foreground location.\r\n * This uses both `requestBackgroundPermissionsAsync` and `getBackgroundPermissionsAsync` to\r\n * interact with the permissions.\r\n *\r\n * @example\r\n * ```ts\r\n * const [status, requestPermission] = Location.useBackgroundPermissions();\r\n * ```\r\n */\r\nexport const useBackgroundPermissions = createPermissionHook({\r\n  getMethod: getBackgroundPermissionsAsync,\r\n  requestMethod: requestBackgroundPermissionsAsync,\r\n});\r\n\r\n// --- Location service\r\n\r\n// @needsAudit\r\n/**\r\n * Checks whether location services are enabled by the user.\r\n * @return A promise which fulfills to `true` if location services are enabled on the device,\r\n * or `false` if not.\r\n */\r\nexport async function hasServicesEnabledAsync(): Promise<boolean> {\r\n  return await ExpoLocation.hasServicesEnabledAsync();\r\n}\r\n\r\n// --- Background location updates\r\n\r\nfunction _validateTaskName(taskName: string) {\r\n  if (!taskName || typeof taskName !== 'string') {\r\n    throw new Error(`\\`taskName\\` must be a non-empty string. Got ${taskName} instead.`);\r\n  }\r\n}\r\n\r\n// @docsMissing\r\nexport async function isBackgroundLocationAvailableAsync(): Promise<boolean> {\r\n  const providerStatus = await getProviderStatusAsync();\r\n  return providerStatus.backgroundModeEnabled;\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Registers for receiving location updates that can also come when the app is in the background.\r\n * @param taskName Name of the task receiving location updates.\r\n * @param options An object of options passed to the location manager.\r\n * @return A promise resolving once the task with location updates is registered.\r\n *\r\n * # Task parameters\r\n *\r\n * Background location task will be receiving following data:\r\n * - `locations` - An array of the new locations.\r\n *\r\n * ```ts\r\n * import * as TaskManager from 'expo-task-manager';\r\n *\r\n * TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { locations }, error }) => {\r\n *  if (error) {\r\n *    // check `error.message` for more details.\r\n *    return;\r\n *  }\r\n *  console.log('Received new locations', locations);\r\n * });\r\n * ```\r\n */\r\nexport async function startLocationUpdatesAsync(\r\n  taskName: string,\r\n  options: LocationTaskOptions = { accuracy: LocationAccuracy.Balanced }\r\n): Promise<void> {\r\n  _validateTaskName(taskName);\r\n  await ExpoLocation.startLocationUpdatesAsync(taskName, options);\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Stops geofencing for specified task.\r\n * @param taskName Name of the background location task to stop.\r\n * @return A promise resolving as soon as the task is unregistered.\r\n */\r\nexport async function stopLocationUpdatesAsync(taskName: string): Promise<void> {\r\n  _validateTaskName(taskName);\r\n  await ExpoLocation.stopLocationUpdatesAsync(taskName);\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * @param taskName Name of the location task to check.\r\n * @return A promise which fulfills with boolean value indicating whether the location task is\r\n * started or not.\r\n */\r\nexport async function hasStartedLocationUpdatesAsync(taskName: string): Promise<boolean> {\r\n  _validateTaskName(taskName);\r\n  return ExpoLocation.hasStartedLocationUpdatesAsync(taskName);\r\n}\r\n\r\n// --- Geofencing\r\n\r\nfunction _validateRegions(regions: LocationRegion[]) {\r\n  if (!regions || regions.length === 0) {\r\n    throw new Error(\r\n      'Regions array cannot be empty. Use `stopGeofencingAsync` if you want to stop geofencing all regions'\r\n    );\r\n  }\r\n  for (const region of regions) {\r\n    if (typeof region.latitude !== 'number') {\r\n      throw new TypeError(`Region's latitude must be a number. Got '${region.latitude}' instead.`);\r\n    }\r\n    if (typeof region.longitude !== 'number') {\r\n      throw new TypeError(\r\n        `Region's longitude must be a number. Got '${region.longitude}' instead.`\r\n      );\r\n    }\r\n    if (typeof region.radius !== 'number') {\r\n      throw new TypeError(`Region's radius must be a number. Got '${region.radius}' instead.`);\r\n    }\r\n  }\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Starts geofencing for given regions. When the new event comes, the task with specified name will\r\n * be called with the region that the device enter to or exit from.\r\n * If you want to add or remove regions from already running geofencing task, you can just call\r\n * `startGeofencingAsync` again with the new array of regions.\r\n * @param taskName Name of the task that will be called when the device enters or exits from specified regions.\r\n * @param regions Array of region objects to be geofenced.\r\n * @return A promise resolving as soon as the task is registered.\r\n *\r\n * # Task parameters\r\n *\r\n * Geofencing task will be receiving following data:\r\n *  - `eventType` - Indicates the reason for calling the task, which can be triggered by entering or exiting the region.\r\n *    See [GeofencingEventType](#geofencingeventtype).\r\n *  - `region` - Object containing details about updated region. See [LocationRegion](#locationregion) for more details.\r\n *\r\n * # Example\r\n * ```ts\r\n * import { GeofencingEventType } from 'expo-location';\r\n * import * as TaskManager from 'expo-task-manager';\r\n *\r\n *  TaskManager.defineTask(YOUR_TASK_NAME, ({ data: { eventType, region }, error }) => {\r\n *   if (error) {\r\n *     // check `error.message` for more details.\r\n *     return;\r\n *   }\r\n *   if (eventType === GeofencingEventType.Enter) {\r\n *     console.log(\"You've entered region:\", region);\r\n *   } else if (eventType === GeofencingEventType.Exit) {\r\n *     console.log(\"You've left region:\", region);\r\n *   }\r\n * });\r\n * ```\r\n */\r\nexport async function startGeofencingAsync(\r\n  taskName: string,\r\n  regions: LocationRegion[] = []\r\n): Promise<void> {\r\n  _validateTaskName(taskName);\r\n  _validateRegions(regions);\r\n  await ExpoLocation.startGeofencingAsync(taskName, { regions });\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * Stops geofencing for specified task. It unregisters the background task so the app will not be\r\n * receiving any updates, especially in the background.\r\n * @param taskName Name of the task to unregister.\r\n * @return A promise resolving as soon as the task is unregistered.\r\n */\r\nexport async function stopGeofencingAsync(taskName: string): Promise<void> {\r\n  _validateTaskName(taskName);\r\n  await ExpoLocation.stopGeofencingAsync(taskName);\r\n}\r\n\r\n// @needsAudit\r\n/**\r\n * @param taskName Name of the geofencing task to check.\r\n * @return A promise which fulfills with boolean value indicating whether the geofencing task is\r\n * started or not.\r\n */\r\nexport async function hasStartedGeofencingAsync(taskName: string): Promise<boolean> {\r\n  _validateTaskName(taskName);\r\n  return ExpoLocation.hasStartedGeofencingAsync(taskName);\r\n}\r\n\r\nexport { LocationEventEmitter as EventEmitter, _getCurrentWatchId };\r\n\r\nexport {\r\n  LocationAccuracy as Accuracy,\r\n  LocationActivityType as ActivityType,\r\n  LocationGeofencingEventType as GeofencingEventType,\r\n  LocationGeofencingRegionState as GeofencingRegionState,\r\n  PermissionStatus,\r\n  PermissionHookOptions,\r\n  setGoogleApiKey,\r\n};\r\n\r\nexport { installWebGeolocationPolyfill } from './GeolocationPolyfill';\r\nexport * from './Location.types';\r\n"]}